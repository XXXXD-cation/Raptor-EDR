// Package detection defines alert structures and related types
package detection

import (
	"time"

	"github.com/XXXXD-cation/Raptor-EDR/pkg/models/common"
	"github.com/XXXXD-cation/Raptor-EDR/pkg/models/enrichment"
)

// Alert represents a security alert generated by detection rules
type Alert struct {
	ID          string          `json:"id" bson:"_id"`
	RuleID      string          `json:"rule_id" bson:"rule_id"`
	RuleName    string          `json:"rule_name" bson:"rule_name"`
	RuleVersion string          `json:"rule_version" bson:"rule_version"`
	
	// Alert classification
	Title       string          `json:"title" bson:"title"`
	Description string          `json:"description" bson:"description"`
	Severity    common.Severity `json:"severity" bson:"severity"`
	Category    string          `json:"category" bson:"category"`
	
	// MITRE ATT&CK context
	MITRETactics    []string `json:"mitre_tactics" bson:"mitre_tactics"`
	MITRETechniques []string `json:"mitre_techniques" bson:"mitre_techniques"`
	
	// Alert status and handling
	Status     AlertStatus `json:"status" bson:"status"`
	AssignedTo string      `json:"assigned_to,omitempty" bson:"assigned_to,omitempty"`
	
	// Source information
	AgentID  string `json:"agent_id" bson:"agent_id"`
	Hostname string `json:"hostname" bson:"hostname"`
	SourceIP string `json:"source_ip,omitempty" bson:"source_ip,omitempty"`
	
	// Related events and evidence
	EventIDs       []string  `json:"event_ids" bson:"event_ids"`
	EventCount     int       `json:"event_count" bson:"event_count"`
	FirstEventTime time.Time `json:"first_event_time" bson:"first_event_time"`
	LastEventTime  time.Time `json:"last_event_time" bson:"last_event_time"`
	
	// Alert context and metadata
	Context     AlertContext                    `json:"context" bson:"context"`
	ThreatIntel enrichment.ThreatIntelData     `json:"threat_intel,omitempty" bson:"threat_intel,omitempty"`
	AssetInfo   enrichment.AssetInfo           `json:"asset_info,omitempty" bson:"asset_info,omitempty"`
	
	// Lifecycle timestamps
	CreatedAt      time.Time  `json:"created_at" bson:"created_at"`
	UpdatedAt      time.Time  `json:"updated_at" bson:"updated_at"`
	AcknowledgedAt *time.Time `json:"acknowledged_at,omitempty" bson:"acknowledged_at,omitempty"`
	ResolvedAt     *time.Time `json:"resolved_at,omitempty" bson:"resolved_at,omitempty"`
	
	// Investigation and response
	Comments []AlertComment   `json:"comments,omitempty" bson:"comments,omitempty"`
	Actions  []ResponseAction `json:"actions,omitempty" bson:"actions,omitempty"`
	Tags     []string         `json:"tags,omitempty" bson:"tags,omitempty"`
}

// AlertStatus represents the current status of an alert
type AlertStatus string

const (
	AlertStatusNew           AlertStatus = "new"
	AlertStatusAcknowledged  AlertStatus = "acknowledged"
	AlertStatusInvestigating AlertStatus = "investigating"
	AlertStatusResolved      AlertStatus = "resolved"
	AlertStatusFalsePositive AlertStatus = "false_positive"
	AlertStatusSuppressed    AlertStatus = "suppressed"
)

// AlertContext contains contextual information about the alert
type AlertContext struct {
	// Process context
	ProcessName string `json:"process_name,omitempty" bson:"process_name,omitempty"`
	ProcessPath string `json:"process_path,omitempty" bson:"process_path,omitempty"`
	CommandLine string `json:"command_line,omitempty" bson:"command_line,omitempty"`
	User        string `json:"user,omitempty" bson:"user,omitempty"`
	
	// Network context
	SourceIP      string `json:"source_ip,omitempty" bson:"source_ip,omitempty"`
	DestinationIP string `json:"destination_ip,omitempty" bson:"destination_ip,omitempty"`
	Domain        string `json:"domain,omitempty" bson:"domain,omitempty"`
	
	// File context
	FilePath string `json:"file_path,omitempty" bson:"file_path,omitempty"`
	FileHash string `json:"file_hash,omitempty" bson:"file_hash,omitempty"`
	
	// Additional context
	Details map[string]interface{} `json:"details,omitempty" bson:"details,omitempty"`
}

// AlertComment represents a comment on an alert
type AlertComment struct {
	ID        string    `json:"id" bson:"id"`
	Author    string    `json:"author" bson:"author"`
	Content   string    `json:"content" bson:"content"`
	CreatedAt time.Time `json:"created_at" bson:"created_at"`
	UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`
}

// ResponseAction represents an action taken in response to an alert
type ResponseAction struct {
	ID          string                 `json:"id" bson:"id"`
	Type        ActionType             `json:"type" bson:"type"`
	Description string                 `json:"description" bson:"description"`
	Status      ActionStatus           `json:"status" bson:"status"`
	Parameters  map[string]string      `json:"parameters,omitempty" bson:"parameters,omitempty"`
	Result      string                 `json:"result,omitempty" bson:"result,omitempty"`
	ExecutedBy  string                 `json:"executed_by" bson:"executed_by"`
	ExecutedAt  time.Time              `json:"executed_at" bson:"executed_at"`
}

// ActionStatus represents the status of a response action
type ActionStatus string

const (
	ActionStatusPending   ActionStatus = "pending"
	ActionStatusExecuting ActionStatus = "executing"
	ActionStatusCompleted ActionStatus = "completed"
	ActionStatusFailed    ActionStatus = "failed"
	ActionStatusCancelled ActionStatus = "cancelled"
)

// NewAlert creates a new alert from a detection rule
func NewAlert(rule *DetectionRule, eventIDs []string) *Alert {
	now := time.Now()
	
	return &Alert{
		RuleID:          rule.ID,
		RuleName:        rule.Name,
		RuleVersion:     rule.Version,
		Title:           rule.Name,
		Description:     rule.Description,
		Severity:        rule.Severity,
		Category:        rule.Category,
		MITRETactics:    rule.MITRETactics,
		MITRETechniques: rule.MITRETechniques,
		Status:          AlertStatusNew,
		EventIDs:        eventIDs,
		EventCount:      len(eventIDs),
		FirstEventTime:  now,
		LastEventTime:   now,
		CreatedAt:       now,
		UpdatedAt:       now,
		Tags:            rule.Tags,
	}
}

// IsOpen returns true if the alert is in an open state
func (a *Alert) IsOpen() bool {
	return a.Status == AlertStatusNew || 
		   a.Status == AlertStatusAcknowledged || 
		   a.Status == AlertStatusInvestigating
}

// IsClosed returns true if the alert is in a closed state
func (a *Alert) IsClosed() bool {
	return a.Status == AlertStatusResolved || 
		   a.Status == AlertStatusFalsePositive || 
		   a.Status == AlertStatusSuppressed
}

// Acknowledge marks the alert as acknowledged
func (a *Alert) Acknowledge(user string) {
	now := time.Now()
	a.Status = AlertStatusAcknowledged
	a.AssignedTo = user
	a.AcknowledgedAt = &now
	a.UpdatedAt = now
}

// Resolve marks the alert as resolved
func (a *Alert) Resolve(user string) {
	now := time.Now()
	a.Status = AlertStatusResolved
	a.ResolvedAt = &now
	a.UpdatedAt = now
	
	// Add resolution comment
	comment := AlertComment{
		ID:        generateID(),
		Author:    user,
		Content:   "Alert resolved",
		CreatedAt: now,
		UpdatedAt: now,
	}
	a.Comments = append(a.Comments, comment)
}

// MarkFalsePositive marks the alert as a false positive
func (a *Alert) MarkFalsePositive(user string, reason string) {
	now := time.Now()
	a.Status = AlertStatusFalsePositive
	a.ResolvedAt = &now
	a.UpdatedAt = now
	
	// Add false positive comment
	comment := AlertComment{
		ID:        generateID(),
		Author:    user,
		Content:   "Marked as false positive: " + reason,
		CreatedAt: now,
		UpdatedAt: now,
	}
	a.Comments = append(a.Comments, comment)
}

// AddComment adds a comment to the alert
func (a *Alert) AddComment(author, content string) {
	now := time.Now()
	comment := AlertComment{
		ID:        generateID(),
		Author:    author,
		Content:   content,
		CreatedAt: now,
		UpdatedAt: now,
	}
	a.Comments = append(a.Comments, comment)
	a.UpdatedAt = now
}

// AddResponseAction adds a response action to the alert
func (a *Alert) AddResponseAction(actionType ActionType, description string, executedBy string) {
	now := time.Now()
	action := ResponseAction{
		ID:          generateID(),
		Type:        actionType,
		Description: description,
		Status:      ActionStatusPending,
		ExecutedBy:  executedBy,
		ExecutedAt:  now,
	}
	a.Actions = append(a.Actions, action)
	a.UpdatedAt = now
}

// GetDuration returns the duration since the alert was created
func (a *Alert) GetDuration() time.Duration {
	if a.ResolvedAt != nil {
		return a.ResolvedAt.Sub(a.CreatedAt)
	}
	return time.Since(a.CreatedAt)
}

// GetEventTimeSpan returns the time span between first and last events
func (a *Alert) GetEventTimeSpan() time.Duration {
	return a.LastEventTime.Sub(a.FirstEventTime)
}

// HasThreatIntel returns true if the alert has threat intelligence data
func (a *Alert) HasThreatIntel() bool {
	return len(a.ThreatIntel.IOCMatches) > 0 || 
		   len(a.ThreatIntel.ThreatActors) > 0 || 
		   len(a.ThreatIntel.Campaigns) > 0
}

// GetRiskScore calculates a risk score based on severity, threat intel, and other factors
func (a *Alert) GetRiskScore() int {
	score := 0
	
	// Base score from severity
	switch a.Severity {
	case common.SeverityLow:
		score = 25
	case common.SeverityMedium:
		score = 50
	case common.SeverityCritical:
		score = 100
	default:
		score = 75 // High
	}
	
	// Boost for threat intelligence matches
	if a.HasThreatIntel() {
		score += 25
	}
	
	// Boost for multiple events
	if a.EventCount > 10 {
		score += 15
	} else if a.EventCount > 5 {
		score += 10
	}
	
	// Cap at 100
	if score > 100 {
		score = 100
	}
	
	return score
}

// generateID generates a unique ID (simplified implementation)
func generateID() string {
	return time.Now().Format("20060102150405") + "-" + "random"
} 